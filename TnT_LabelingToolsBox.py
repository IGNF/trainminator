# -*- coding: utf-8 -*-/
"""
/***************************************************************************
TnT_LabelingToolsBox
                                 A QGIS plugin
Labelisation de données segmentées.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        authors              : Yann Le Borgne
        email                : yann.le-borgne@ign.fr
        version              : 1.3.0

  15/03/2022: Ajout de "traces" d' entree dans les méthodes.

 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import inspect

from qgis.gui  import (QgsLayerTreeMapCanvasBridge, QgsMapTool)
from qgis.core import (QgsProject, QgsLayerTreeGroup)
from qgis.utils import iface

from PyQt5           import  QtCore
from PyQt5.QtCore    import (Qt, QMargins, QEvent)
from PyQt5.QtGui     import (QKeySequence)
from PyQt5.QtWidgets import (QSizePolicy, QWidget, QPushButton,
                             QLabel, QSlider, QSpacerItem,
                             QVBoxLayout, QHBoxLayout, QGroupBox,
                             QShortcut, QMainWindow, QMessageBox)

from .TnT_ProjectDataManager import TnTprojectDataManager
from .TnT_MergingLabeledData import TnTmergingLabeledData
from .TnT_CaptureManager     import TnTmapToolEmitPoint_V2, TnTmapToolEmitPline_V2, TnTmapToolEmitPolygon_V2
from .TnT_MapCanvas          import TnTmapCanvas

def lineno():
    """Returns the current line number in Python source code"""
    return inspect.currentframe().f_back.f_lineno

class TnTlabelingToolsBox(QGroupBox):
    """class dedicated to data labeling."""
    def __init__(self,  mainWindow:QMainWindow, parent:QWidget ):
        QGroupBox.__init__(self, parent)

        #self.widgetParent=widgetParent
        self.mainWindow=mainWindow
        self.canvas=mainWindow.getCanvas()
        self.mapTool=None
        # self.layout = None
        self.comm=self.mainWindow.comm

        self.codeSelectedValue=None
        self.labelSelectedValue=None
        self.labelColorSelected=None

        self.layerTreeMapCanvasBridge=None

        self.save_start_button_state=False

        self.flagShow=False

        self.initialDisplayState={}

        #Graphics elements
        self.slider=None

        #List of labeled layer (used by slider)
        self.listLabeledLayers=[]
        self.indexActiveLabeledLayer=0

        #List of labeled layer (used for merging)
        self.listLabeledLayers4Merging=[]

        #List of ShortCut object
        self.listShortCuts=[]

        self.setupUi("LABELING")

        self.projectDataManager=TnTprojectDataManager(self)
        self.projectDataManager.init()

    def clear(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.getGroupBox("Project").setEnabled(False)

    def startControlTool(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        target_groupName=self.projectDataManager.mandatoryGroups[3]
        try :
            tLayer=self.getRootGroup().findGroup(target_groupName).findLayers()[0]
            self.projectDataManager.addTreeLayerTreeControl(target_groupName, tLayer)
        except IndexError :
            msg="You must \"Start\" labeling mode and generate finals data set (press \"Fill Pyramid\" button) before using this \"Control tool\".\n"
            self.showMsgBox(msg, QMessageBox.Warning)

    def getListLabeledLayers(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        tmp=self.projectDataManager.getListLabeledLayers().copy()
        tmp.reverse()
        return tmp

    def getListLabeledLayers4Merging(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.projectDataManager.getListLabeledLayers().copy()

    def setMainWindow(self, mainWindow):
        """
            returns none:
        """
        # print(f"line:{lineno()},TnTlabelingToolsBox->setMainWindow()")
        self.mainWindow=mainWindow

    def getMainWindow(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.mainWindow

    def setActiveCanvas(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.getMainWindow().setActiveCanvas(self.getCanvas())

    def getActiveCanvas(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.getMainWindow().getActiveCanvas()

    def unsetActiveCanvas(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.getMainWindow().unsetActiveCanvas()

    def getAdditionalCanvas(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.mainWindow.getAdditionalCanvas()

    def getRootGroup(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.mainWindow.getRootGroup()

    def toggleTextButton(self, pushButton, textON, textOFF):
        """
            param pushButton:
            param textON:
            param textOFF:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        t=(lambda:textON, lambda:textOFF)[pushButton.isChecked()]()
        pushButton.setText(t)

    def setCanvas(self, canvas):
        """
            param canvas:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.canvas=canvas

    def getCanvas(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.canvas

    #About slider
    def setSlider(self, slider):
        """
            param slider:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.slider=slider

    def getSlider(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        return self.slider

    def showMsgBox(self, text, icon=QMessageBox.Information):
        """
        Contruct and show a new message box
            param text: message text.
            param icon: This argument holds the message box icon, defaut value QMessageBox.Information.
                         QMessageBox.NoIcon, the message box does not have any icon.
                         QMessageBox.Question, an icon indicating that the message is asking a question.
                         QMessageBox.Information, an icon indicating that the message is nothing out of the ordinary.
                         QMessageBox.Warning, an icon indicating that the message is a warning, but can be dealt with.
                         QMessageBox.Critical, an icon indicating that the message represents a critical problem.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        messageBox = QMessageBox()
        messageBox.setIcon(icon)
        messageBox.setWindowTitle("TrainMinaTor message")
        messageBox.setText(text)
        messageBox.setStandardButtons(QMessageBox.Ok)
        #messageBox.setStyleSheet(self.QMessageBoxCSS)
        messageBox.exec()

    def setupUi(self, title, contentsMargins=QMargins(5,5,5,5), spacing=10 ):
        """
            param title:
            param contentsMargins:
            param spacing:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.setTitle(title)
        self.setAccessibleName(title)
        self.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        layout = QHBoxLayout(self)
        layout.setContentsMargins(contentsMargins)
        layout.setSpacing(spacing)
        self.setLayout(layout)

        #leftSide (contain slider, info  and canvas)
        leftSideWidget=self.setupVWidget()
        leftSideWidget_layout=leftSideWidget.layout()

        sizePolicy = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)

        #Add slider and co
        sliderBlock=self.initSliderGroup(self.setupHWidget())
        sliderBlock.setSizePolicy(sizePolicy)
        leftSideWidget_layout.addWidget(sliderBlock)

        self.comm.lockAssociatedButton.connect(lambda:(self.slider.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda:(self.slider.setEnabled(True)))

        #Add capture info (current nomenclature, current class etc...)
        captureInfoGroup=self.initCaptureInfoGroup(self.setupHWidget())
        captureInfoGroup.setSizePolicy(sizePolicy)
        leftSideWidget_layout.addWidget(captureInfoGroup)

        #Create Canvas and add it
        canvasName="Canvas_"+self.title()
        self.canvas = TnTmapCanvas(self, canvasName)
        # sizePolicy = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Minimum)
        leftSideWidget_layout.addWidget(self.canvas)

        layout.addWidget(leftSideWidget)

        rightSideWidget=self.setupVWidget()
        rightSideWidget_layout=rightSideWidget.layout()

        self.initToolsCaptureGroup(rightSideWidget_layout)

        layout.addWidget(rightSideWidget)

    def setupVWidget(self, contentsMargins=QMargins(0,0,0,0) , spacing=10):
        """
            param contentsMargins:
            param spacing:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        wd = QWidget(self)
        layout = QVBoxLayout(wd)
        layout.setContentsMargins(contentsMargins)
        layout.setSpacing(spacing)
        return wd

    def setupHWidget(self, contentsMargins=QMargins(0,0,0,0) , spacing=10):
        """
            param contentsMargins:
            param spacing:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        wd = QWidget(self)
        layout = QHBoxLayout(wd)
        layout.setContentsMargins(contentsMargins)
        layout.setSpacing(spacing)
        return wd

    def initSliderGroup(self, hWidget):
        """
            param hWidget:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.setSlider( QSlider( Qt.Horizontal, hWidget) )

        slider=self.getSlider()
        slider.setMinimum(1)
        slider.setMaximum(1)
        slider.setTickInterval(1)
        slider.setTickPosition(QSlider.TicksAbove)
        slider.setPageStep(1)
        slider.setSingleStep(1)

        labelOfSlider = QLabel(hWidget)
        labelOfSlider.setObjectName("slider_Label")
        text="NO LEVEL"
        labelOfSlider.setText(text)

        hWidget.layout().addWidget(labelOfSlider)
        hWidget.layout().addWidget(self.getSlider())

        self.initSliderShortcut()
        self.getSlider().valueChanged.connect(lambda:(labelOfSlider.setText(self.listLabeledLayers[self.getSlider().value()-1].layer().name())))
        self.getSlider().valueChanged.connect(lambda:(self.activateSegmentLevel(int(self.getSlider().value()))))

        self.comm.sliderResetValue.connect(lambda:(labelOfSlider.setText(text)))
        self.comm.sliderInitValue.connect(lambda:(labelOfSlider.setText(self.listLabeledLayers[0].layer().name())))

        self.getSlider().setEnabled(False)

        return hWidget

    def initCaptureInfoGroup(self, hWidget):
        """
            param hWidget:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        layout=hWidget.layout()

        label = QLabel(hWidget)
        label.setText("CURRENT NOMENCLATURE:")
        label.setObjectName("currentNomenclature_Label")
        #label.setStyleSheet(self.QLabelCSS)
        layout.addWidget(label)

        labelNomenclatureValue = QLabel(hWidget)
        labelNomenclatureValue.setText("NO NOMENCLATURE")
        #labelNomenclatureValue.setStyleSheet(self.QLabelCSS)
        layout.addWidget(labelNomenclatureValue)

        spacerItem = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum )
        layout.addItem(spacerItem)

        label = QLabel(hWidget)
        label.setText("CURRENT CLASS:")
        label.setObjectName("currentClass_Label")
        #label.setStyleSheet(self.QLabelCSS)
        layout.addWidget(label)

        codeSelectedValue = QLabel(hWidget)
        codeSelectedValue.setText("No code")
        #codeSelectedValue.setStyleSheet(self.QLabelCSS)
        layout.addWidget(codeSelectedValue)

        labelSelectedValue = QLabel(hWidget)
        labelSelectedValue.setText("No class")
        #labelSelectedValue.setStyleSheet(self.QLabelCSS)
        layout.addWidget(labelSelectedValue)

        labelColorSelected = QLabel(hWidget)
        labelColorSelected.setText("#000000")
        #labelColorSelected.setStyleSheet(self.QLabelCSS)
        layout.addWidget(labelColorSelected)

        self.comm.updateCurrentNomenclatureInfo.connect(lambda name:
                                                        self.currentNomenclatureInfoChanged(name,
                                                                                            labelNomenclatureValue)
                                                        )
        self.comm.updateCurrentClassInfo.connect(lambda rowClassSelected:
                                                 self.currentClassInfoChanged(rowClassSelected,
                                                                              [codeSelectedValue,labelSelectedValue,labelColorSelected])
                                                 )

        return hWidget

    def initToolsCaptureGroup(self, layoutParent):
        """
            param layoutParent:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        #====================================================
        #Begin Project GROUP
        groupBoxProj=self.setupGroup("Project")
        pushButton= self.setupButton(groupBoxProj,
                                      "Start",
                                      "Start/stop labeling",
                                      "Start/stop labeling ",
                                      None,
                                      True)
        pushButton.setFocusPolicy(Qt.NoFocus)
        self.setInitialState(pushButton, True, False)

        pushButton.clicked.connect(self.labelingData)
        self.comm.lockAssociatedButton.connect(lambda: (pushButton.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda: (pushButton.setEnabled(True)))

        groupBoxProj.layout().addWidget(pushButton)

        pushButton_pyramid=self.setupButton(groupBoxProj,
                                      "Fill Pyramid",
                                      "Finish labeling and merge pyramid layers ",
                                      "Finish labeling and merge pyramid layers ",
                                      None,
                                      False)

        self.setInitialState(pushButton_pyramid, False, False)

        pushButton_pyramid.clicked.connect(self.enterFinishMode)
        self.comm.lockAssociatedButton.connect(lambda: (pushButton_pyramid.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda: (pushButton_pyramid.setEnabled(True)))

        groupBoxProj.layout().addWidget(pushButton_pyramid)
        layoutParent.addWidget(groupBoxProj)
        groupBoxProj.setEnabled(False)

        self.comm.enableLabelingGroupBoxes.connect(lambda: (groupBoxProj.setEnabled(True)))
        self.comm.disableLabelingGroupBoxes.connect(lambda: (groupBoxProj.setEnabled(False)))


        #End Project GROUP
        #====================================================

        #====================================================
        #Begin Project CAPTURE
        shortCutText="F1"
        groupBoxCap=self.setupGroup("Capture", QMargins(5,1,1,1), 0)
        groupBox=self.setupGroup("Task")
        pushButton_label=self.setupButton(groupBox,
                                     "Labeling",
                                     "Labeling segment ("+shortCutText+")",
                                     "Labeling segment",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_label, True, False)
        pushButton_label.clicked.connect(self.setMutuallyExclusiveState)
        groupBox.layout().addWidget(pushButton_label)

        shortCutText="F2"
        pushButton_deleteAll=self.setupButton(groupBox,
                                     "Delete All",
                                     "Remove all classes  ("+shortCutText+")",
                                     "Remove all classes from the selection",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_deleteAll, True, False)
        pushButton_deleteAll.clicked.connect(self.setMutuallyExclusiveState)
        groupBox.layout().addWidget(pushButton_deleteAll)
        groupBoxCap.layout().addWidget(groupBox)


        shortCutText="F3"
        pushButton_deleteCurrent=self.setupButton(groupBox,
                                     "Delete Current",
                                     "Remove the current class ("+shortCutText+")",
                                     "Remove the current class from the selection",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_deleteCurrent, True, False)
        pushButton_deleteCurrent.clicked.connect(self.setMutuallyExclusiveState)
        groupBox.layout().addWidget(pushButton_deleteCurrent)
        groupBoxCap.layout().addWidget(groupBox)

        groupBox=self.setupGroup("Selecting By")

        shortCutText="F4"
        pushButton_point=self.setupButton(groupBox,
                                     "Point",
                                     "Activate selecting by point ("+shortCutText+")",
                                     "Activate selecting by point",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_point, True, False)
        pushButton_point.clicked.connect(self.setMutuallyExclusiveState)
        pushButton_point.clicked.connect( lambda:(self.enterModePoint(self.canvas)) )
        self.comm.lockAssociatedButton.connect(lambda:(pushButton_point.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda:(pushButton_point.setEnabled(True)))
        groupBox.layout().addWidget(pushButton_point)

        shortCutText="F5"
        pushButton_line=self.setupButton(groupBox,
                                     "Line",
                                     "Activate selecting by PolyLine ("+shortCutText+")",
                                     "Activate selecting by PolyLine",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_line, True, False)
        pushButton_line.clicked.connect(self.setMutuallyExclusiveState)
        pushButton_line.clicked.connect( lambda:(self.enterModePline(self.canvas)) )
        self.comm.lockAssociatedButton.connect(lambda:pushButton_line.setEnabled(False))
        self.comm.unLockAssociatedButton.connect(lambda:(pushButton_line.setEnabled(True)))
        groupBox.layout().addWidget(pushButton_line)

        shortCutText="F6"
        pushButton_polygon1=self.setupButton(groupBox,
                                     "Large-Polygon",
                                     "Select the entities which intersect or contained in the Polygon ("+shortCutText+")",
                                     "Select the entities which intersect or contained in the Polygon",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_polygon1, True, False)
        pushButton_polygon1.clicked.connect(self.setMutuallyExclusiveState)
        pushButton_polygon1.clicked.connect( lambda:(self.enterModeIPolygon(self.canvas)) )
        self.comm.lockAssociatedButton.connect(lambda:(pushButton_polygon1.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda:(pushButton_polygon1.setEnabled(True)))
        groupBox.layout().addWidget(pushButton_polygon1)

        shortCutText="F7"
        pushButton_polygon2=self.setupButton(groupBox,
                                     "Strict-Polygon",
                                     "Select the entities contained in the Polygon ("+shortCutText+")",
                                     "Select the entities contained in the Polygon",
                                     shortCutText,
                                     True)
        self.setInitialState(pushButton_polygon2, True, False)
        pushButton_polygon2.clicked.connect(self.setMutuallyExclusiveState)
        pushButton_polygon2.clicked.connect( lambda:(self.enterModeEPolygon(self.canvas)) )
        self.comm.lockAssociatedButton.connect(lambda:(pushButton_polygon2.setEnabled(False)))
        self.comm.unLockAssociatedButton.connect(lambda:(pushButton_polygon2.setEnabled(True)))
        groupBox.layout().addWidget(pushButton_polygon2)
        groupBoxCap.layout().addWidget(groupBox)

        groupBoxCap.setEnabled(False)

        layoutParent.addWidget(groupBoxCap)
        #End Project CAPTURE
        #====================================================

        #====================================================
        #Begin Project DISPLAY
        groupBoxDisplay=self.setupGroup("Display")

        shortCutText="Alt+C"
        pushButton_showCurrentClass= self.setupButton(groupBoxDisplay,
                                      "Show Current",
                                      "Show only the data of current Class. ("+shortCutText+")",
                                      "Show only the data of current Class.",
                                      shortCutText,
                                      True)

        self.setInitialState(pushButton_showCurrentClass, True, False)

        pushButton_showCurrentClass.clicked.connect(self.showOnlyCurrentClass1)
        groupBoxDisplay.layout().addWidget(pushButton_showCurrentClass)

        shortCutText="Alt+L"
        pushButton_Codes= self.setupButton(groupBoxDisplay,
                                      "Show Codes",
                                      "Show or hide code value of the data of LABELED_DATA group. ("+shortCutText+")",
                                      "Show or hide code value of the data of LABELED_DATA group.",
                                      shortCutText,
                                      True)
        self.setInitialState(pushButton_Codes, True, False)

        pushButton_Codes.clicked.connect(self.showHideLabels)
        groupBoxDisplay.layout().addWidget(pushButton_Codes)

        shortCutText="Space"
        pushButton_ortho= self.setupButton(groupBoxDisplay,
                                      "Show Context",
                                      "Show only the data of CONTEXT group. ("+shortCutText+")",
                                      "Show only the data of CONTEXT group.",
                                      None,
                                      False)

        self.setInitialState(pushButton_ortho, True, False)
        self.flagShow=True

        pushButton_ortho.pressed.connect(lambda:(self.showOneGroup("CONTEXT")))
        pushButton_ortho.released.connect(self.restoreInitialDisplayState)
        groupBoxDisplay.layout().addWidget(pushButton_ortho)

        layoutParent.addWidget(groupBoxDisplay)
        groupBoxDisplay.setEnabled(False)
        #End Project DISPLAY
        #====================================================

        spacerItem = QSpacerItem(20, 40, QSizePolicy.Minimum, QSizePolicy.Expanding)
        layoutParent.addItem(spacerItem)


    #===================================================================
    # About Slider actions

    def showOnlyCurrentClass1(self):
        """
            param sender:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        sender = self.sender()
        if sender.isChecked():
            self.projectDataManager.setStateOfOneRule( self.listLabeledLayers,
                                                       self.projectDataManager.dictCodeRuleKey,
                                                       self.mainWindow.nomenclatureWidget.rowClassSelected[1],
                                                       True)
        else:
            self.projectDataManager.setStatesOfAllRules( self.listLabeledLayers,True)

    def changeCurrentClassShowing1(self):
        """
            param sender:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        sender = self.sender()
        if sender.isChecked():
            self.projectDataManager.setStateOfOneRule(self.listLabeledLayers,
                                                      self.projectDataManager.dictCodeRuleKey,
                                                      self.mainWindow.nomenclatureWidget.rowClassSelected[1],
                                                      True)
        else: #Nothing
            pass

    def initSliderShortcut(self):
        """
        Instantiation of the shortcuts assigned to the slider.
        TAB, "p" key pressed = next level of segmentation
        CTRL+TAB, "o" key pressed = prev level of segmentation.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        Shortcut_NextLevel=QShortcut(QKeySequence("Tab"),self)
        Shortcut_NextLevel.activated.connect(self.nextLevel)

        Shortcut_NextLevel1=QShortcut(QKeySequence("p"),self)
        Shortcut_NextLevel1.activated.connect(self.nextLevel)

        Shortcut_PreviousLevel=QShortcut(QKeySequence("Ctrl+Tab"),self)
        Shortcut_PreviousLevel.activated.connect(self.previousLevel)

        Shortcut_PreviousLevel2=QShortcut(QKeySequence("o"),self)
        Shortcut_PreviousLevel2.activated.connect(self.previousLevel)

    def nextLevel(self):
        """
        This method is executed each time the TAB key is pressed.
        Increments the current value of the slider with the value of the next segment level.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        if self.getSlider().isEnabled() :
            if self.getSlider().value()==self.slider.maximum():
                self.getSlider().setValue(self.getSlider().minimum())
            else:
                self.getSlider().setValue(self.getSlider().value()+1)

    def previousLevel(self):
        """
        This method is executed each time the CTRL+TAB keys is pressed.
        Decrement the value of the slider with the value of the previous segment level.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        if self.getSlider().isEnabled():
            if self.getSlider().value()==self.slider.minimum():
                self.getSlider().setValue(self.getSlider().maximum())
            else:
                self.getSlider().setValue(self.getSlider().value()-1)

    def activateSegmentLevel(self, newIndex):
        """
        This method is executed each time the value of the slider changes.
            param newIndex: index of the new segmented layer to be activated and displayed.
                            set attribut self.indexActiveLabeledLayer.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}(newIndex={newIndex})")
        self.setIndexActiveLabeledLayer(newIndex-1)
        for layer2setVibility in self.listLabeledLayers:
            layer2setVibility.setItemVisibilityChecked(False)

        for layer2setVibility in self.listLabeledLayers[0:newIndex]:
            if not layer2setVibility.isVisible():
                layer2setVibility.setItemVisibilityChecked(True)

    #===================================================================

    #===================================================================
    def currentNomenclatureInfoChanged(self, nomenclatureName, target:QLabel):
        """
            nomenclatureName: new nomenclature name selected by user in nomenclatureQComboBox.
            target :  Qlabels target whose text is initialized with nomenclature name.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}(\
        #                                               nomenclatureName={nomenclatureName},\
        #                                               target={target})")

        target.setText(nomenclatureName)


    def currentClassInfoChanged(self, rowClassSelected, listTarget):
        """
            rowClassSelected: new row selected by user in nomenclatureQTreeWidget.
            listTarget : list of Qlabels target whose text is initialized with newtext contains in rowClassSelected.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}(\
        #                                               {rowClassSelected})")

        listTarget[0].setText(rowClassSelected[0])
        listTarget[1].setText(rowClassSelected[1].upper())
        listTarget[2].setText(rowClassSelected[2])
        listTarget[2].setStyleSheet("QLabel {font-style :normal; "
                                            "border-radius :2px;"
                                            "border-style :solid;"
                                            "border-width :1px;"
                                            "border-color :black;"
                                            "background-color :"+rowClassSelected[2]+";"
                                            "color :"+rowClassSelected[2]+";}")

    def setupGroup(self, title, contentsMargins=QMargins(1,1,1,1) , spacing=10):
        """
            param title: title of QGroupBox
            param contentsMargins: apply this QMargins
            param spacing: spacing between graphics elements , default 10px.
            returns QGroupBox: a new QGroupBox.
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        gb = QGroupBox(self)
        gb.setObjectName(title.replace(' ','_'))
        gb.setTitle(title)
        gb.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        layout = QVBoxLayout(gb)
        layout.setContentsMargins(contentsMargins)
        layout.setSpacing(spacing)
        return gb

    def setupButton(self, parent, text="NoName", toolTip=None, whatsThis=None, keySequence=None , checkable=False):
        """
            param parent: Makes this QPushButton as a child of parent.
            param Text: This argument holds the text shown on the button.
            param toolTip: This argument holds the widget's tooltip.
            param whatsThis: This argument holds the widget's What's This help text.
            param styleSheet: This argument holds the widget's style sheet
            param keySequence: QKeySequence object for the given keySequence argument.
            param checkable: This argument holds whether the button is checkable, By default, the button is not checkable.
            returns pb: New instance of QPushButton.
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        pb = QPushButton(parent)
        pb.setObjectName(text.replace(' ','_'))
        pb.setText(text)
        pb.default = False
        pb.autoDefault = False

        if toolTip:
            pb.setToolTip(toolTip)

        if whatsThis:
            pb.setWhatsThis(whatsThis)

        pb.setCheckable(checkable)

        if keySequence:
            sc_pb= QShortcut(QKeySequence(keySequence),self)
            sc_pb.activated.connect(pb.animateClick)
        return pb

    def setEnabledGroupBoxTarget(self, nomenclatureSelector, groupboxTarget):
        """
            param nomenclatureSelector:
            param groupboxTarget:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #     {inspect.currentframe().f_code.co_name}(\
        #                                             {nomenclatureSelector},\
        #                                             {groupboxTarget.title()})")

        index=nomenclatureSelector.currentIndex()
        text=nomenclatureSelector.currentText()

        if index!=-1 and text!=nomenclatureSelector.parent().nomenclatureNameMsg :
            groupboxTarget.setEnabled(True)

    def showHideLabels(self):
        """
            param sender:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        sender=self.sender()
        if sender.isChecked():
            self.showLabels()
        else:
            self.showLabels(False)

        self.toggleTextButton(sender, "Show Codes", "Hide Codes")

    def showLabels(self, state=True):
        """
            param state:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        root = self.getRootGroup()
        group=root.findGroup('LABELED_DATA')
        for LayerTreeLayer in group.findLayers():
            LayerTreeLayer.layer().setLabelsEnabled(state)
            LayerTreeLayer.layer().triggerRepaint()

    def showOneGroup(self, groupName2Show):
        """
            param groupName2Show:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        # Disable evt pressed before processing
        buttonSource=self.sender()
        buttonSource.pressed.disconnect()

        treeRoot=self.getRootGroup()
        for child in treeRoot.children():
            if isinstance(child, QgsLayerTreeGroup):
                self.initialDisplayState[child.name()]=child.itemVisibilityChecked()
                if child.name() == groupName2Show:
                    child.setItemVisibilityChecked(True)
                else:
                    child.setItemVisibilityChecked(False)

    def restoreInitialDisplayState(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        treeRoot=self.getRootGroup()
        for groupName in self.initialDisplayState:
            group=treeRoot.findGroup(groupName)
            group.setItemVisibilityChecked(self.initialDisplayState[groupName])

        #Enable evt pressed after release  (re connect exist???)
        buttonSource=self.sender()
        buttonSource.pressed.connect(lambda:(self.showOneGroup("CONTEXT")))

    def setIndexActiveLabeledLayer(self, indexActiveLabeledLayer):
        """
            param indexActiveLabeledLayer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.indexActiveLabeledLayer=indexActiveLabeledLayer

    def getIndexActiveLabeledLayer(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        return self.indexActiveLabeledLayer

    def getActiveLabeledLayer(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        return self.listLabeledLayers[self.getIndexActiveLabeledLayer()]

    def getNameOfActiveLabeledLayer(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        return self.listLabeledLayers[self.getIndexActiveLabeledLayer()].name()

    def setMutuallyExclusiveState(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        buttonSource=self.sender()
        children=buttonSource.parentWidget().children()
        for child in children :
            if isinstance(child, QPushButton) and  child != buttonSource:
                child.setEnabled(True)
                child.setChecked(False)

    def removeAllChildren(self, groupName):
        """
            param groupName:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #    {inspect.currentframe().f_code.co_name}()")
        treeRoot=self.getRootGroup()
        group=treeRoot.findGroup(groupName)
        for tLayer in group.findLayers():
            id_layer=tLayer.layer().id()
            QgsProject.instance().removeMapLayer(id_layer)

    def setInitialState(self, buttonTarget, enabledState, checkedState):
        """
            param buttonTarget:
            param enabledState:
            param checkedState:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}(buttonTarget={buttonTarget},\
        #       enabledState={enabledState},\
        #       checkedState={checkedState})")

        buttonTarget.setEnabled(enabledState)
        buttonTarget.setChecked(checkedState)

    def getPushButton(self, button_objectName):
        """
            param buttonText:
            returns QPushButton:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}({buttonText})")

        result=self.findChild(QPushButton, button_objectName)
        return result

        # l=self.findChildren(QPushButton)
        # for b in l:
        #     if b.text()==buttonText:
        #         return b
        # return None

    def getGroupBox(self ,groupText):
        """
            param groupText:
            returns QGroupBox:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}({groupText})")

        l=self.findChildren(QGroupBox)
        for b in l:
            if b.title()==groupText:
                return b
        return None

    def labelingData(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        sender=self.sender()
        # if buttonSource.text() == "Start":
        if sender.isChecked() :
            self.save_start_button_state = True
            self.enterStartMode()
        # elif buttonSource.text() == "Stop":
        elif not sender.isChecked() :
            self.enterStopMode()
            self.save_start_button_state = False
        else:
            print(f"line 1093 , labelingData(): bad state:{self.sender().text()}")
        self.toggleTextButton(sender, "Start", "Stop")

    def getListButtonWithOutSender(self, sender):
        """
            param sender:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        GroupBoxSelecting=self.getGroupBox("Selecting By")
        childrenButtons=GroupBoxSelecting.findChildren(QPushButton)
        childrenButtons.remove(sender)
        return childrenButtons

    def enterStartMode(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        #Prohibits any modifications to projects during user input operations
        #lock project menu acces
        iface.projectMenu().setEnabled(False)
        #and lock file toolBar acces
        iface.fileToolBar().setEnabled(False)

        self.getGroupBox("Capture").setEnabled(True)
        self.getGroupBox("Display").setEnabled(True)

        #Now it's possible too fill pyramid
        #self.getPushButton("Fill_pyramid").setEnabled(True)
        self.getPushButton("Fill_Pyramid").setEnabled(True)

        # self.labelingMode=False

        #For started Select mode Labeling
        # In this case, Do not used animateClick delay on realease
        # is too long.
        # self.getPushButton("Labeling").animateClick()
        pb = self.getPushButton("Labeling")
        pb.setChecked(True)
        pb.clicked.emit()
        #Now self.labelingMode is True

        #set Selecting By point,
        self.getPushButton("Point").animateClick()

        self.startLabelingData()

        #Lock nomenclatureSelector (ie coud'nt change nomenclature until press "stop")
        self.mainWindow.nomenclatureWidget.nomenclatureQComboBox.setEnabled(False)

        #self.startMode=True
        self.mainWindow.disableWindowCloseButton()

    def enterStopMode(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        #Check if additionnel view is open: close it if user click on Stop button
        try :
            b_t=self.getPushButton("additionalView_pushButton")
            if b_t.isChecked():
                b_t.animateClick()
        except AttributeError :
            pass

        try :
            #b_t=self.getPushButton("Hide Codes")
            b_t=self.getPushButton("Hide_Codes")
            b_t.setChecked(False)
            b_t.clicked.emit()
        except AttributeError :
            pass

        try :
            #b_t=self.getPushButton("Show Current")
            b_t=self.getPushButton("Show_Current")
            b_t.setChecked(False)
            b_t.clicked.emit()
        except AttributeError :
            pass

        gb=self.getGroupBox("Capture")
        for pushButton in gb.findChildren(QPushButton):
            self.setInitialState(pushButton, True, False)
        gb.setEnabled(False)

        gb=self.getGroupBox("Display")
        for pushButton in gb.findChildren(QPushButton):
            self.setInitialState(pushButton, True, False)
        gb.setEnabled(False)

        #Now it's not possible too fill pyramid
        #self.getPushButton("Fill pyramid").setEnabled(False)
        self.getPushButton("Fill_Pyramid").setEnabled(False)

        self.stopLabelingData()

        #unLock nomenclatureSelector (ie coud'nt change nomenclature until press "start")
        self.mainWindow.nomenclatureWidget.nomenclatureQComboBox.setEnabled(True)

        #self.startMode=False
        self.mainWindow.enableWindowCloseButton()

        #Unlock menu project on Qgis main window
        iface.projectMenu().setEnabled(True)
        #and Unlock file toolBar access
        iface.fileToolBar().setEnabled(True)

    def startLabelingData(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.projectDataManager.loadDataLabeled(self.mainWindow.nomenclatureWidget)
        self.listLabeledLayers=self.getListLabeledLayers()
        self.listLabeledLayers4Merging=self.getListLabeledLayers4Merging()

        #Group SEGMENTED_DATA & FINAL visibility false
        self.projectDataManager.setVisibilityGroup(self.projectDataManager.mandatoryGroups[1], False)
        self.projectDataManager.setVisibilityGroup(self.projectDataManager.mandatoryGroups[3], False)
        #Group LABELED_DATA visibility True
        self.projectDataManager.setVisibilityGroup(self.projectDataManager.mandatoryGroups[2], True)

        self.activateSegmentLevel(1)
        #Set slider with the correct values and activate it
        slider=self.getSlider()
        slider.setMaximum(len(self.listLabeledLayers))
        slider.setEnabled(True)

        if slider.value() != 1:
            slider.setValue(1)
        else:
            #Already to 1, force emit signal for changing text of Qlabel with new name active level
            self.comm.sliderInitValue.emit()

        self.mainWindow.nomenclatureWidget.nomenclatureQTreeWidget.itemSelectionChanged.emit()

    def  stopLabelingData(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.comm.sliderResetValue.emit()
        self.getSlider().setValue(1)
        self.getSlider().setEnabled(False)

        #Clear list of labeled layers and reset index.
        self.listLabeledLayers.clear()
        self.listLabeledLayers4Merging.clear()
        self.setIndexActiveLabeledLayer(None)

        self.projectDataManager.removeAllChildren("LABELED_DATA")
        self.projectDataManager.removeAllChildren("FINAL_DATA")

        # self.getCanvas().unsetMapTool(self.getMapTool())
        # # unsetMapTool
        # self.setMapTool()

        canvas=self.getCanvas()
        self.mapTool=QgsMapTool(canvas)
        canvas.setMapTool(self.mapTool)

    def enterFinishMode(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        testM=TnTmergingLabeledData(self)
        testM.mergeAll(self.listLabeledLayers4Merging)

    def enterModePoint(self, canvas=None):
        """
            param canvas:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.mapTool = TnTmapToolEmitPoint_V2(self, canvas)
        canvas.setMapTool(self.mapTool)


    def enterModePline(self, canvas=None):
        """
            param canvas:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.mapTool = TnTmapToolEmitPline_V2(self, canvas)
        canvas.setMapTool(self.mapTool)

    def enterModeIPolygon(self, canvas=None):
        """
            param canvas:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.mapTool = TnTmapToolEmitPolygon_V2(self, canvas, strictMode=False)
        canvas.setMapTool(self.mapTool)

    def enterModeEPolygon(self, canvas=None):
        """
            param canvas:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.mapTool = TnTmapToolEmitPolygon_V2(self, canvas, strictMode=True)
        canvas.setMapTool(self.mapTool)

    def event(self, event: QEvent):
        """
            param event:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}(event={event})")

        if event.type()==QEvent.Show:
            self.setActiveCanvas()
            self.getCanvas().setSlave( self.getAdditionalCanvas() )
            self.layerTreeMapCanvasBridge=QgsLayerTreeMapCanvasBridge(
                self.mainWindow.tntLayerTreeView.getLayerTreeRoot(),
                self.getCanvas()
                )
            return True

        if event.type()==QEvent.Hide:
            del self.layerTreeMapCanvasBridge
            self.getCanvas().unsetSlave()
            self.unsetActiveCanvas()
            return True

        return QWidget.event(self, event)
