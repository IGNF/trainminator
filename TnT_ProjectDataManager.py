# -*- coding: utf-8 -*-
"""
/***************************************************************************
 TnT_projectDataManager
                                 A QGIS plugin
 test de nouveau plugin
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        authors              : Yann Le Borgne
        email                : yann.le-borgne@ign.fr
        version              : 1.3.0
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import inspect

from qgis.utils import iface
from qgis.core  import (QgsProject, QgsVectorLayer, QgsLayerTreeLayer,
                        QgsWkbTypes, QgsRuleBasedRenderer, QgsVectorFileWriter,
                        QgsFillSymbol,QgsField, QgsPalLayerSettings,
                        QgsTextFormat, QgsTextBufferSettings, QgsVectorLayerSimpleLabeling,
                        QgsLinePatternFillSymbolLayer )


from PyQt5           import QtCore
from PyQt5.QtWidgets import QProgressDialog, QMessageBox
from PyQt5.QtGui     import (QColor, QFont)

def lineno():
    """Returns the current line number in Python source code"""
    return inspect.currentframe().f_back.f_lineno

class TnTprojectDataManager():
    """
    Class dedicated to data management on the qgis project side.
    """

    def __init__(self, parent):
        self.parent=parent

        self.root = None
        self.projectName=None
        self.absoluteFilePath=None
        self.projectAbsolutePath=None
        self.layerTreeRoot=None

        self.dataAbsolutePath=None

        self.projectSaved=False
        self.projectValid=False

        self.nomenclatureName=''
        self.projectStructure= {}

        self.messages=[]

        # mandatory group
        self.mandatoryGroups=['CONTEXT',
                              'SEGMENTED_DATA',
                              'LABELED_DATA',
                              'FINAL_DATA']

        self.included_extensions=['shp','gpkg','tif','tiff']
        self.raster_extensions=['tif','tiff']
        self.vector_extensions=['shp','gpkg']
        self.dictCodeRuleKey={}
        self.styleSheet_segmentedData = {'color':'',
                                         'outline_color':'#eeff01',
                                         'line_color':'#eeff01',
                                         'width_border':'0.25',
                                          'style':'no'  }


        self.styleSheet_unlabeled = {'color':'',
                                      'outline_color':'yellow',
                                      'width_border':'0.10',
                                      'style':'no' }

        self.styleSheet_labeled = {'color':'' ,
                                    'outline_color':'black',
                                    'width_border':'0.10',
                                    'style':'no' }

        self.styleSheet_Default = {'color':'' ,
                                   'outline_color':'black',
                                   'width_border':'0.05',
                                   'style':'no' }

        self.styleSheet_NoLabel = {'color':'transparent',
                                   'outline_color':'black',
                                   'width_border':'0,70',
                                   'style':'solid line' }

    def info(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->info()")
        print(f"---> self.projectSaved        : {self.projectSaved}")
        print(f"---> self.projectValid        : {self.projectValid}")
        print(f"---> self.absoluteFilePath    : {self.absoluteFilePath}")
        print(f"---> self.projectAbsolutePath : {self.projectAbsolutePath}")
        print(f"---> self.dataAbsolutePath    : {self.dataAbsolutePath}")
        print(f"---> self.projectStructure    : {self.projectStructure}")

    def getListLabeledLayers(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->getListLabeledLayers()")
        return self.projectStructure[self.mandatoryGroups[2]]['TREELAYERS']

    def setProjectValid(self, projectValid=False):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->setProjectValid()")
        self.projectValid=projectValid

    def getProjectValid(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->setProjectValid()")
        return self.projectValid

    def setRootGroup(self, layerTreeRoot):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->setRootGroup()")
        self.layerTreeRoot=layerTreeRoot

    def getRootGroup(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->getRootGroup()")
        return self.layerTreeRoot

    def setProjectAttr(self):
        """
            returns none:
        """
        # print(f"line:{lineno()}, TnTprojectDataManager->setProjectAttr()")
        self.root=QgsProject.instance()
        self.projectName=self.root.baseName()
        self.absoluteFilePath=self.root.absoluteFilePath()
        self.projectAbsolutePath=self.root.absolutePath()
        self.layerTreeRoot=self.root.layerTreeRoot()

    def init(self):
        """
            returns none:
        """
        # print(f"line:{lineno()}, TnTprojectDataManager->init()")
        self.setProjectAttr()

        if self.absoluteFilePath:
            #group LABELED_DATA and FINAL_DATA must be contain no layers
            self.cleanGroup(self.mandatoryGroups[2])
            self.cleanGroup(self.mandatoryGroups[3])

            self.checkMandatoryGroups()

            if self.getProjectValid():
                # Sort segmented data from most to least segmented
                sorted_segs=[]
                sorted_segs=self.sortingSegmentedData(self.mandatoryGroups[1])
                self.sortingSegmentedLayer(self.mandatoryGroups[1], sorted_segs)
            else:
                self.clear()
                self.showMessage(self.messages, QMessageBox.Critical)

    def clear(self):
        """
        This method is executed when the project is cleared (and additionally when an open project
        is cleared just before a new project is read).
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #     {inspect.currentframe().f_code.co_name}()")

        self.projectSaved=False
        self.projectValid=False
        self.nomenclatureName=''
        self.projectStructure.clear()

        self.layerTreeRoot=None
        self.projectAbsolutePath=None
        self.projectName=None
        self.dataAbsolutePath=None


    def readProject(self):
        """
        This method is executed when a project is being read.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")
        self.init()

    def checkMandatoryGroups(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")

        self.setProjectValid(True)
        self.messages.clear()
        for mandatoryGroupsName in self.mandatoryGroups:
            if not self.getRootGroup().findGroup(mandatoryGroupsName):
                msg=r'Mandatory group:%s doesn\'t exist, Project not valid' % mandatoryGroupsName
                self.messages.append(msg)
                self.setProjectValid(False)
            else:
                self.setGroupInfo(mandatoryGroupsName)

    def cleanGroup(self, groupName):
        """
         Remove all maps from the target group "groupName"
            param groupName:The name of the group to clean
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")
        group=self.getRootGroup().findGroup(groupName)
        tLayers=group.findLayers()

        for tLayer in tLayers:
            id_layer=tLayer.layer().id()
            QgsProject.instance().removeMapLayer(id_layer)


    def setGroupInfo(self, groupName):
        """
            param groupName:The name of the target group.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")
        self.projectStructure[groupName]={}
        self.projectStructure[groupName]['DATASOURCE']=""
        self.projectStructure[groupName]['TREELAYERS']=[]

        group=self.getRootGroup().findGroup(groupName)
        tLayers=group.findLayers()

        #if empty
        if not tLayers:
            self.projectStructure[groupName]['DATASOURCE']=''

        for tLayer in tLayers :
            if tLayer.layer().isValid():
                self.projectStructure[groupName]['TREELAYERS'].append(tLayer)
            else :
                id_layer=tLayer.layer().id()
                QgsProject.instance().removeMapLayer(id_layer)

        if self.projectStructure[groupName]['TREELAYERS'] :
            result=self.projectStructure[groupName]['TREELAYERS'][0].layer().dataProvider().dataSourceUri()
            head_tail = os.path.split(result)
            self.projectStructure[groupName]['DATASOURCE']=head_tail[0]


    def createFillSymbol(self, nomenclatureWidget, vlayer):
        """
            param nomenclatureWidget:
            param vlayer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}()")
        rootrule = QgsRuleBasedRenderer.Rule(None)
        sym0 = QgsFillSymbol.createSimple({'color'        : self.styleSheet_unlabeled['color'],
                                           'outline_color': self.styleSheet_unlabeled['outline_color'],
                                           'width_border' : self.styleSheet_unlabeled['width_border'],
                                           'style'        : self.styleSheet_unlabeled['style']})
        sym0.setOpacity(1)
        rx0=QgsRuleBasedRenderer.Rule(sym0, 0, 0, 'ELSE')

        rootrule.appendChild(rx0)
        self.dictCodeRuleKey[vlayer.name()]={}

        for key in nomenclatureWidget.colorClassAssociation:
            Hex_color=nomenclatureWidget.colorClassAssociation[key]
            Int_color=  int(Hex_color.split('#')[1],16)
            sym = QgsFillSymbol.createSimple({'color'        : str(Hex_color),
                                              'outline_color': self.styleSheet_labeled['outline_color'],
                                              'width_border' : self.styleSheet_labeled['width_border']})
            sym.setOpacity(0.60)
            rx1=QgsRuleBasedRenderer.Rule(sym, 0, 0, '"color" = {}'.format(Int_color))
            self.dictCodeRuleKey[vlayer.name()][key]=rx1.ruleKey()
            rx0.appendChild(rx1)

        vlayer.setRenderer(QgsRuleBasedRenderer(rootrule))

    def setStateOfOneRule(self, tlayers, dictCodeRuleKey, currentLabel, state):
        """
            param tlayers:
            param dictCodeRuleKey:
            param currentLabel:
            param state:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->\
        #       {inspect.currentframe().f_code.co_name}(tlayers={tlayers},\
        #                                               dictCodeRuleKey={dictCodeRuleKey},\
        #                                               currentLabel={dictCodeRuleKey},\
        #                                               state={state})")
        self.setStatesOfAllRules(tlayers, not state)
        for tlayer in tlayers :
            rule_target=(tlayer.layer().renderer().rootRule().children())[0].findRuleByKey(dictCodeRuleKey[tlayer.layer().name()][currentLabel])
            rule_target.setActive(state)

    def setStatesOfAllRules(self, tlayers, state):
        """
            param tlayers:
            param state:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->setStateAllRules({state={state})")
        for tlayer in tlayers :
            rules=(tlayer.layer().renderer().rootRule().children())[0].children()
            for rule in rules:
                rule.setActive(state)
            tlayer.layer().triggerRepaint()

    def createFillSymbolControl(self, vlayer, elseRule):
        """
            param tlayers:
            param elseRule:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->createFillSymbolControl()")
        rootrule = QgsRuleBasedRenderer.Rule(None)
        sym0 = QgsFillSymbol.createSimple({'color'        : self.styleSheet_Default['color'],
                                           'outline_color': self.styleSheet_Default['outline_color'],
                                           'width_border' : self.styleSheet_Default['width_border'],
                                           'style'        : self.styleSheet_Default['style']
                                           })

        sym0.setOpacity(0.75)
        rx0=QgsRuleBasedRenderer.Rule(sym0, 0, 0, 'ELSE')
        rootrule.appendChild(rx0)

        symbol_lyr_line = QgsLinePatternFillSymbolLayer()
        symbol_lyr_line.setLineAngle(45)
        symbol_lyr_line.setDistance(2)
        symbol_lyr_line.setLineWidth(0.9)
        symbol_lyr_line.setColor(QColor(255,121,0))

        symbol_line = QgsFillSymbol.createSimple({ 'color'        : self.styleSheet_NoLabel['color'],
                                                   'outline_color': self.styleSheet_NoLabel['outline_color'],
                                                   'width_border' : self.styleSheet_NoLabel['width_border']})

        symbol_line.setOpacity(1)
        symbol_line.appendSymbolLayer(symbol_lyr_line)

        rx=QgsRuleBasedRenderer.Rule(symbol_line, 0, 0, elseRule )
        rootrule.appendChild(rx)

        vlayer.setRenderer(QgsRuleBasedRenderer(rootrule))

    def addTreeLayerTreeControl(self, groupName, tLayer):
        """
            param groupName:
            param tLayer:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->addTreeLayerTreeControl(groupName:{groupName}, tLayer:{tLayer})")

        iface.setActiveLayer( tLayer.layer() )
        vl = iface.activeLayer()
        new_layer=iface.addVectorLayer(vl.source(), vl.name() + "_CTRL", vl.providerType())
        new_layer.setName(vl.name() + "_CTRL")  #grrrrrrrrrrrr font ch...
        self.createFillSymbolControl(new_layer,'"code" IS NULL')
        target_group=self.getRootGroup().findGroup(groupName)
        target_group.setItemVisibilityChecked(True)

    def printProjectStructure(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->printProjectStructure()")
        print(f"self.projectStructure:{self.projectStructure}")
        for k in self.projectStructure:
            print(f"Group : {k}")
            for k1 in self.projectStructure[k]:
                print(f"    {k1} : {self.projectStructure[k][k1]}")

    def sortingSegmentedData(self, segmentedDataGroupName):
        """
            param segmentedDataGroupName:
            returns none:
        """
        # print(f"line:{lineno()}, TnTprojectDataManager->sortingSegmentedData(segmentedDataGroupName:{segmentedDataGroupName})")
        segmentedDataGroup=self.getRootGroup().findGroup(segmentedDataGroupName)
        sorted_segments=[]
        segments={}
        for tLayer in segmentedDataGroup.findLayers():
            polygonNumber=0
            for feat in tLayer.layer().getFeatures():
                geom = feat.geometry()
                if geom.type() == QgsWkbTypes.PolygonGeometry:
                    polygonNumber+=1
            segments[tLayer]=polygonNumber

        sort_segments=sorted(segments.items(), key=lambda x: x[1], reverse=True)
        for values in sort_segments:
            tLayer=values[0]
            tLayer.setExpanded(False)
            tLayer.setItemVisibilityChecked(False)
            sorted_segments.append(tLayer)
        return sorted_segments

    def sortingSegmentedLayer(self, segmentedDataGroupName, segments):
        """
            param segmentedDataGroupName:
            param segments:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->sortingSegmentedLayer(segmentedDataGroupName:{segmentedDataGroupName},segments:{segments})")
        root = QgsProject.instance().layerTreeRoot()
        self.projectStructure[segmentedDataGroupName]['TREELAYERS'].clear()
        index=1
        for segment in segments :
            vLayer = QgsProject.instance().mapLayersByName(segment.layer().name())[0]
            vLayer_treeLayer = root.findLayer(vLayer.id())
            vLayer_treeLayer_clone = vLayer_treeLayer.clone()
            parent_group = vLayer_treeLayer.parent()
            parent_group.insertChildNode(index,vLayer_treeLayer_clone)
            vLayer_treeLayer_clone.setExpanded(False)
            vLayer_treeLayer_clone.setItemVisibilityChecked(False)

            parent_group.removeChildNode(segment)
            self.projectStructure[segmentedDataGroupName]['TREELAYERS'].append(vLayer_treeLayer_clone)
            index+=1


    def setVisibilityGroup(self, groupName , visibility):
        """
            param groupName:
            param visibility:
            returns none:
        """
        groupTarget=self.getRootGroup().findGroup(groupName)
        groupTarget.setItemVisibilityChecked(visibility)

    def loadDataLabeled(self, nomenclatureWidget):
        """
            param nomenclatureWidget:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->loadDataLabeled(nomenclatureWidget:{nomenclatureWidget})")
        labeledGroup=QgsProject.instance().layerTreeRoot().findGroup(self.mandatoryGroups[2])

        currentNomenclatureName=nomenclatureWidget.nomenclatureQComboBox.currentText()
        AbsolutePath_DataLabeled=self.projectAbsolutePath+"/LABELED_DATA"+"/"+currentNomenclatureName.upper()

        listDataSegmented=self.projectStructure[self.mandatoryGroups[1]]['TREELAYERS']

        progress=self.showDialog(self.parent, "Loading", "Loading labeled data...")
        progress.setMinimum(0)
        progress.setMaximum(len(listDataSegmented))

        index=1
        progress.setValue(0)
        for dataSegmented in listDataSegmented:
            filedata_name= os.path.split(dataSegmented.layer().dataProvider().dataSourceUri())[1]
            data_name=filedata_name.split('.')[0]
            FullPathName_DataLabeled=AbsolutePath_DataLabeled+"/"+filedata_name

            if os.path.isfile(FullPathName_DataLabeled) :
                vlayer_DataLabeled = QgsVectorLayer(FullPathName_DataLabeled,
                                                    data_name,
                                                   "ogr")
                self.checkAttributs(nomenclatureWidget, vlayer_DataLabeled)

                if vlayer_DataLabeled.isValid():
                    print(f"Reload/Load data {FullPathName_DataLabeled}")
                else :
                    vlayer_DataLabeled=None
                    print("Layer failed to load!")

            else :
                vlayer_DataSegmented=dataSegmented.layer()
                options = QgsVectorFileWriter.SaveVectorOptions()

                os.makedirs(AbsolutePath_DataLabeled, exist_ok=True)

                options.driverName = vlayer_DataSegmented.dataProvider().storageType()
                transformContext = QgsProject.instance().transformContext()
                QgsVectorFileWriter.writeAsVectorFormatV2(vlayer_DataSegmented,
                                                          FullPathName_DataLabeled,
                                                          transformContext,
                                                          options)

                vlayer_DataLabeled = QgsVectorLayer(FullPathName_DataLabeled,
                                                    data_name,
                                                    "ogr")
                self.createAttributs(nomenclatureWidget, vlayer_DataLabeled)

            if vlayer_DataLabeled :
                self.createFillSymbol(nomenclatureWidget, vlayer_DataLabeled)

                labels=self.createLayerLabeling(fieldName='code')
                vlayer_DataLabeled.setLabelsEnabled(False)
                vlayer_DataLabeled.setLabeling(labels)

                QgsProject.instance().addMapLayer(vlayer_DataLabeled,False)
                layerTreeLayer_DataLabeled=QgsLayerTreeLayer(vlayer_DataLabeled)
                labeledGroup.insertChildNode(index, layerTreeLayer_DataLabeled)

                layerTreeLayer_DataLabeled.setExpanded(False)
                layerTreeLayer_DataLabeled.setItemVisibilityChecked(False)

                self.projectStructure[self.mandatoryGroups[2]]['TREELAYERS'].append(layerTreeLayer_DataLabeled)

                progress.setValue(progress.value()+1)
                index+=1

        progress.setLabelText("Loading data Done.")
        progress.setValue(progress.maximum())
        progress.close()

    def removeAllChildren(self, groupName):
        """
            param groupName:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->removeAllChildren(groupName:{groupName})")
        treeRoot=self.getRootGroup()
        group=treeRoot.findGroup(groupName)
        for tLayer in group.findLayers():
            id_layer=tLayer.layer().id()
            QgsProject.instance().removeMapLayer(id_layer)
        self.parent.mainWindow.activeCanvas.refresh()
        self.projectStructure[groupName]['TREELAYERS'].clear()

    def checkAttributs(self, nomenclatureWidget, vlayer):
        """
            Checks whether all the attributes declared in the nomenclature file exist in the data already labeled.
            param nomenclatureWidget: a nomenclature widget.
            param vlayer: vector layer to check.
            returns none:
        """
        result=False

        dictTemp=nomenclatureWidget.tableAttributs.copy()
        dictRes={}

        pr = vlayer.dataProvider()
        field_names = [field.name() for field in pr.fields()]
        for field in field_names:
            if field in dictTemp:
                del dictTemp[field]

        if not dictTemp or (dictTemp==nomenclatureWidget.tableAttributs):
            result=True
        else:
            dictRes=set(nomenclatureWidget.tableAttributs.items())^set(dictTemp.items())

        return result


    def createAttributs(self, nomenclatureWidget, vlayer):
        """
            param nomenclatureWidget:
            param vlayer:
            returns none:
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->createAttributs(nomenclatureWidget:{nomenclatureWidget}, vlayer:{vlayer})")
        pr = vlayer.dataProvider()
        field_names = [field.name() for field in pr.fields()]
        #for attribut in self.tableAttributs:
        for attribut in nomenclatureWidget.tableAttributs:
            if not attribut in field_names:
                # <name>, <type>
                # pr.addAttributes([QgsField(attribut, self.tableAttributs[attribut])])
                pr.addAttributes([QgsField(attribut, nomenclatureWidget.tableAttributs[attribut])])
        vlayer.updateFields()

    def createLayerLabeling(self, fieldName):
        """
        Constructs simple labeling configuration with given initial settings.
        The text will contain the fieldName field value.
        Using when user want to show labels
            param fieldName:
            returns label: return a new simple labeling configuration with given initial settings.
        """
        #print(f"line:{lineno()}, TnTprojectDataManager->createLayerLabeling(fieldName:{fieldName})")
        settings=QgsPalLayerSettings()
        text_format = QgsTextFormat()
        text_format.setFont(QFont('Arial', 8))
        text_format.setColor(QColor('Black'))
        buffer = QgsTextBufferSettings()
        buffer.setEnabled(True)
        buffer.setSize(0.50)
        buffer.setColor(QColor('grey'))
        text_format.setBuffer(buffer)
        settings.setFormat(text_format)
        settings.fieldName = fieldName
        settings.isExpression = False
        label = QgsVectorLayerSimpleLabeling(settings)
        return label

    # def checkGroupOnReload(self, grTarget_Name):
    #     """
    #     Checks if the group data can be reloaded with the selected nomenclature.
    #     param groupTarget: a targetGroup.
    #     return none:
    #     """
    #     grTarget = QgsProject.instance().layerTreeRoot().findGroup(grTarget_Name)
    #     for tLayer in grTarget.findLayers():
    #         print(f"**** tLayer:{tLayer}")
    #         print(f"**** tLayer.layer().id():{tLayer.layer().id()}")
    #         print(f"**** tLayer.layer().name():{tLayer.layer().name()}")

    def showMessage(self, messages, icon=QMessageBox.Information):
        """


        Parameters
        ----------
        messages : TYPE
            DESCRIPTION.
        icon : TYPE, optional
            DESCRIPTION. The default is QMessageBox.Information.

        Returns
        -------
        None.

        """
        messageBox = QMessageBox()
        messageBox.setIcon(icon)
        messageBox.setWindowTitle("TrainMinaTor message")
        messageBox.setText('\n'.join(messages))
        messages.clear()
        messageBox.setStandardButtons(QMessageBox.Ok)
        messageBox.exec()

    def showDialog(self, parent, windowTitle, labelText):
        """
            param parent:
            param windowTitle:
            param labelText:
            returns none:
        """
        #print(f"line:{lineno()}, ->TnTprojectDataManager:showDialog(windowTitle:{},labelText:{labelText} )")
        progress = QProgressDialog(parent)
        progress.setWindowTitle(windowTitle)
        progress.setLabelText(labelText)
        progress.setCancelButtonText(None)
        progress.setMinimumDuration(5)
        progress.setWindowModality(QtCore.Qt.WindowModal)
        progress.setAutoClose(False)
        progress.setAutoReset(False)
        return progress
