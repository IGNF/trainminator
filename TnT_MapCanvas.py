# -*- coding: utf-8 -*-/
"""
/***************************************************************************
TnT_MapCanvas
                                 A QGIS plugin
Labelisation de données segmentées.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        email                : yann.le-borgne@ign.fr
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import inspect

from qgis.gui import (QgsMapCanvas, QgsVertexMarker, QgsMapTool) 
from qgis.core import(QgsPoint, QgsPointXY)

from PyQt5.QtCore    import (Qt, QEvent)
from PyQt5.QtGui     import ( QColor, QFocusEvent, QMouseEvent )


class TnTmapCanvas( QgsMapCanvas ):
    
    def __init__(self, parent=None, name=None):
        super(TnTmapCanvas, self).__init__(parent)
        self.parent=parent
        self.name=name    
        self.slave=None
        #Synchro mode , default=False at starting
        self.synchroMode=False
        self.qgsmaptool=QgsMapTool(self)          
        self.setUpUi()
        
        Focus_yellow='#FFC829'
        self.defaultStyle= """QgsMapCanvas {
                                        border: 1px solid grey;
                                        border-radius: 4px;
                                        padding:2px
                                        }"""

        self.hoverStyle= """QgsMapCanvas:focus {
                                            border: 3px solid"""+Focus_yellow+""";
                                            border-radius: 4px;
                                            padding:2px
                                        }"""
    
        self.setStyleSheet(self.defaultStyle+self.hoverStyle)
        
    def setUpUi(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas: setupUi()")
        self.setCanvasColor(Qt.white)
        self.setDefaultMarker()
        
    
    def setDefaultMarker(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas: setDefaultMarker()")
        self.marker = QgsVertexMarker(self)
        self.marker.setColor(QColor(255,255,255))
        self.marker.setIconSize(30)
        self.marker.setIconType(QgsVertexMarker.ICON_CROSS )
        self.marker.setPenWidth(2)
       
    def extChange(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas: extChange()")
        try: self.getSlave().extChangeSlave( self.extent() )
        except AttributeError: pass 
           
    def extChangeSlave(self, extent):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas: extChangeSlave(extent:{extent})")
        self.extentsChanged.disconnect()
        self.setExtent(extent)
        self.refresh()
        self.extentsChanged.connect(self.extChange)
    
    def showMousePointerMarker(self, p):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas: showMousePointerMarker(p:{p})")
        """ This method display the mouse pointer (marker) at <p> position in canvas of slave view. 
            @param p: .
            @type p: QgsPointXY.
        """  
        self.marker.setCenter(p)
        self.marker.show()
                
    def lineno(self):
         """ Bug: Returns the current line number"""   
         return inspect.currentframe().f_back.f_lineno
     
    def setName(self, name="no name"):
        self.name=name
        
    def getName(self):
        return self.name
     
    def setSlave(self, slave=None):
        self.slave=slave
            
    def unsetSlave(self):      
        self.setSlave()
              
    def getSlave(self):
        return self.slave
    
    def info(self):
        print("=================================================================")
        print(f"            self.name: {self.name}")
        if self.slave: print(f"          self.slave: {self.slave}+{self.slave.name}")
        else :         print("           self.slave: NO SALVE+NO NAME")       
        print(f"     self.synchroMode: {self.synchroMode}")
        print("=================================================================")
        print("")
    
    def setSynchroMode(self, synchroMode=False):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:getSynchroMode(synchroMode={synchroMode})")
        """ This method instantiates the synchronization mode between the main and the additional view.
            used : self.setSynchroMode()=synchronisation mode OFF.
            @param synchroMode: set synchronisation mode ON (True) or OFF (False)
            @type synchroMode: Boolean.
        """
        self.synchroMode=synchroMode
        
    def getSynchroMode(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:getSynchroMode()")
        """ This method return state of synchronization mode.
            @param None:.
        """
        return self.synchroMode 
    
    def toggleStateSynchroMode(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:toggleStateSynchroMode()")
        """ This method is called when the user presses the button <Synchro View>.
            Toggle state of mode synchronisation mode.
            @param None:.
        """ 
        if self.getSynchroMode(): self.synchroModeOFF() 
        else : self.synchroModeON()
           
    def synchroModeON(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:synchroModeON()")
        """ Activate the functionalities of the synchronization mode between the views.
            Same visible area. 
            Same position of the mouse pointer.
            @param None:.
        """     
        self.setSynchroMode(True)
        self.extentsChanged.connect(self.extChange)
        self.xyCoordinates.connect(self.getSlave().showMousePointerMarker)  
     
    def synchroModeOFF(self):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:synchroModeOFF()")
        """ Deactivate the functionalities activated by the synchroModeON() method.
            @param None:.
        """  
        self.setSynchroMode()
        self.extentsChanged.disconnect()
        self.xyCoordinates.disconnect()
        self.marker.hide()
     
    def syncZoom (self):
        print(f"line:{self.lineno()}, ->TnTmapCanvas:syncZoom()")
        """ Synchronization of the zooms between the main and additional view.
            @param None:.
        """      
        if self.getSynchroMode() : self.getSlave().setTransform(self.transform(),False)
      
         
    def mouseMoveEvent(self, event:QMouseEvent):
        self.marker.hide()
        try: self.slave
        except AttributeError: pass 
        else :
            if self.synchroMode:
                  qgspointXY =self.qgsmaptool.toMapCoordinates(event.pos())	
                  self.slave.showMousePointerMarker(qgspointXY)
     
        return QgsMapCanvas.mouseMoveEvent(self, event)
        
    def event(self, event: QEvent):
        #print(f"line:{self.lineno()}, ->TnTmapCanvas:event(event:{event})")
        evt_Type=event.type()               
        if evt_Type==QEvent.KeyPress and event.key()==Qt.Key_Space:
            #Additional view canvas does not have a toolbox, ignore error 
            try:  self.parent.getPushButton('Show Context').keyPressEvent(event) 
            except AttributeError: pass       
            return True
        
        elif evt_Type==QEvent.KeyRelease and event.key()==Qt.Key_Space :
            #Additional view canvas does not have a toolbox, ignore error 
            try:  self.parent.getPushButton('Show Context').keyReleaseEvent(event)
            except AttributeError: pass       
            return True
        
        else:
            return QgsMapCanvas.event(self, event)