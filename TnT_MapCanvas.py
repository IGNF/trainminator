# -*- coding: utf-8 -*-/
"""
/***************************************************************************
TnT_MapCanvas
                                 A QGIS plugin
Labelisation de données segmentées.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        authors              : Yann Le Borgne
        email                : yann.le-borgne@ign.fr
        version              : 1.3.0
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import inspect
import os.path

from qgis.gui import (QgsMapCanvas, QgsVertexMarker, QgsMapTool)

from PyQt5 import QtCore
from PyQt5.QtCore    import (Qt, QEvent)
from PyQt5.QtGui     import ( QColor, QMouseEvent )


def lineno():
    """Returns the current line number in Python source code"""
    return inspect.currentframe().f_back.f_lineno

class TnTmapCanvas(QgsMapCanvas):
    """
    Canvas handling class.
    """

    def __init__(self, parent=None, name="NoName_TnTmapCanvas"):
        QgsMapCanvas.__init__(self, parent)

        self.setObjectName(name)
        self.setMapTool(QgsMapTool(self),True)

        self.slave=None
        #Synchro mode , default=False at starting
        self.synchroMode=False
        self.marker=None

        css_File=u"css/Default.css"
        css_Path=os.path.join(os.path.dirname(__file__), css_File)
        rc = QtCore.QFile(css_Path)
        rc.open(QtCore.QFile.ReadOnly)
        content = rc.readAll().data()
        self.setStyleSheet(str(content, "utf-8"))

        self.setUpUi()

    def setUpUi(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->setupUi()")
        self.setCanvasColor(Qt.white)
        self.setDefaultMarker()

    def setDefaultMarker(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->setDefaultMarker()")
        self.marker = QgsVertexMarker(self)
        self.marker.setColor(QColor(255,255,255))
        self.marker.setIconSize(30)
        self.marker.setIconType(QgsVertexMarker.ICON_CROSS )
        self.marker.setPenWidth(2)

    def extentChange(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->extentChange()")
        try:
            self.slave.extentChange_Slave( self.extent() )
        except AttributeError:
            pass

    def extentChange_Slave(self, extent):
        """
            param extent:
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->extentChange_Slave(extent:{extent})")
        self.extentsChanged.disconnect()
        self.setExtent(extent)
        self.refresh()
        self.extentsChanged.connect(self.extentChange)

    def showMousePointerMarker(self, p):
        """
        This method display the mouse pointer (marker) at <p> position
        in canvas of slave view.
            param p: mouse pointer position  QgsPointXY.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->showMousePointerMarker(p:{p})")

        self.marker.setCenter(p)
        self.marker.show()

    def setSlave(self, mapCanvas=None):
        """
            param slave:
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->setSlave({mapCanvas})")
        self.slave=mapCanvas

    def unsetSlave(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->unsetSlave()")
        self.setSlave()

    def getSlave(self):
        """
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->getSlave()")
        return self.slave

    def setSynchroMode(self, synchromode=False):
        """
        This method instantiates the synchronization mode between the main and
        the additional view.
        Default synchromode OFF.
        used : self.setSynchroMode() (synchronisation mode OFF).

            param synchromode:set synchronisation mode ON (True) or OFF (False)
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->getSynchroMode(synchromode={synchromode})")
        self.synchroMode=synchromode

    def getSynchroMode(self):
        """
        This method return state of synchronization mode.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->getSynchroMode()")
        return self.synchroMode

    def toggleStateSynchroMode(self):
        """
        This method is called when the user presses the button <Synchro View>.
        Toggle state of mode synchronisation mode.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->toggleStateSynchroMode()")
        if self.getSynchroMode():
            self.synchroModeOFF()
        else:
            self.synchroModeON()

    def synchroModeON(self):
        """
        Activate the functionalities of the synchronization mode between the views.
        Same visible area and Same position of the mouse pointer.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->synchroModeON()")
        self.setSynchroMode(True)
        self.extentsChanged.connect(self.extentChange)
        self.xyCoordinates.connect(self.getSlave().showMousePointerMarker)

    def synchroModeOFF(self):
        """
        Deactivate the functionalities activated by the synchroModeON() method.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->synchroModeOFF()")
        self.setSynchroMode()
        self.extentsChanged.disconnect()
        self.xyCoordinates.disconnect()
        self.marker.hide()

    def syncZoom (self):
        """
        Synchronization of the zooms between the main and additional view.
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->syncZoom()")
        if self.getSynchroMode():
            self.getSlave().setTransform(self.transform(),False)

    def mouseMoveEvent(self, event:QMouseEvent):
        """
            param event:
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->mouseMoveEvent(event:{event})")
        self.marker.hide()
        try:
            self.slave
        except AttributeError:
            pass
        else :
            if self.synchroMode:
                qgspointXY =self.mapTool().toMapCoordinates(event.pos())
                self.getSlave().showMousePointerMarker(qgspointXY)

        return QgsMapCanvas.mouseMoveEvent(self, event)

    def event(self, event: QEvent):
        """
            param event:
            returns none:
        """
        #print(f"line:{lineno()}, TnTmapCanvas->event(event:{event})")
        evt_Type=event.type()
        if evt_Type==QEvent.KeyPress and event.key()==Qt.Key_Space:
            #Additional view canvas does not have a toolbox, ignore error
            try:
                self.parent().getPushButton('Show Context').keyPressEvent(event)
            except AttributeError:
                pass
            return True

        if evt_Type==QEvent.KeyRelease and event.key()==Qt.Key_Space :
            #Additional view canvas does not have a toolbox, ignore error
            try:
                self.parent().getPushButton('Show Context').keyReleaseEvent(event)
            except AttributeError:
                pass
            return True

        return QgsMapCanvas.event(self, event)
