# -*- coding: utf-8 -*-/
"""
/***************************************************************************
TnT_MergingLabeledData
                                 A QGIS plugin
Labelisation de données segmentées.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        authors              : Yann Le Borgne
        email                : yann.le-borgne@ign.fr
        version              : 1.3.0

30/03/2022 Changement dans la classe TnTnomenclatureWidget des methodes d'acces
           aux champs attributaires.

15/03/2022: Ajout de "traces" d' entree dans les méthodes.
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import inspect
import time
import glob
import os
import processing

from PyQt5 import QtCore
from PyQt5.QtWidgets import (QProgressDialog, QMessageBox)
from PyQt5.QtCore import QTimer

from qgis.core import (QgsProject, QgsVectorLayer,
                       QgsProcessingFeatureSourceDefinition,
                       QgsFeatureRequest, QgsVectorDataProvider,
                       QgsLayerTreeLayer, QgsVectorFileWriter)



def lineno():
    """Returns the current line number in Python source code"""
    return inspect.currentframe().f_back.f_lineno

class TnTmergingLabeledData():
    """
    Class responsible for merging the different segmented layers.
    """
    def __init__(self,
                 masterWindow=None
                 ):

        self.masterWindow=masterWindow
        self.workGroupName='FINAL_DATA'
        self.absolutePathFinalData = None
       

        self.vLayersList = []
        self.mostSegmentedLayer = None
        self.dictOfvLayersListByVintageToKeep = {}

        self.dictFieldIndex = {}
        self.listOfAttValues={}

    def setAbsolutePathFinalData(self, path:str=None):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        self.absolutePathFinalData = path


    def getAbsolutePathFinalData(self):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        return self.absolutePathFinalData

    def initvLayersList(self, group):
        """
        This list contains all labeled vector layers.
        Those present in the "LABELED_DATA_<vintage>" group in differential
        labeling mode or  "LABELED_DATA" in normal labeling mode.

        Warning the list created is sorted from the most segmented layer
        to the least segmented

        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        self.vLayersList.clear()
        layers = group.findLayers()
        for index,_ in enumerate(layers, 1):
            self.vLayersList.append(layers[-index].layer())

    def initDictOfvLayersListByVintageToKeep(self, vintages:list):
        """
        Dictionary of lists classified by vintage.
        Each of the lists will contain the layers having at least one
        labeled segment.
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        self.dictOfvLayersListByVintageToKeep.clear()
        for vintage in vintages:
            self.dictOfvLayersListByVintageToKeep[vintage]=[]


    def createDir(self, dirName:str=None):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        projectAbsolutePath=QgsProject.instance().absolutePath()
        AbsolutePath_FinalData=f"{projectAbsolutePath}/{dirName}"
        os.makedirs(AbsolutePath_FinalData, exist_ok=True)
        self.setAbsolutePathFinalData(AbsolutePath_FinalData)
           
    def clearAttrs(self):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        self.vLayersList = []
        self.mostSegmentedLayer = None
        self.dictOfvLayersListByVintageToKeep = {}

        self.dictFieldIndex = {}
        self.listOfAttValues={}
      
    def cleanData(self):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        layerTreeWidget = self.masterWindow.getTnTLayerTreeWidget()
        root = layerTreeWidget.layerTreeRoot()
        group = root.findGroup(self.workGroupName)
        
        layers = group.findLayers()
        if layers :
            vLayer = layers[0].layer()
            id_vLayer = vLayer.id()
             
            QgsProject.instance().removeMapLayer(id_vLayer)
            group.removeAllChildren()
            
            absolutePathFinalData=self.getAbsolutePathFinalData()
            if absolutePathFinalData :
                files = glob.glob(f"{absolutePathFinalData}/*.*")
                for f in files:
                    os.remove(f)
          
    def merge(self):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        self.cleanData()
        self.clearAttrs()

        nomenclatureWidget = self.masterWindow.getTnTnomenclatureWidget()
        nomenclatureName = nomenclatureWidget.getComboBox().currentText()

        self.createDir(
            dirName=f"{self.workGroupName}/{nomenclatureName.upper()}")

        layerTreeWidget = self.masterWindow.getTnTLayerTreeWidget()
        root = layerTreeWidget.layerTreeRoot()

        vintage = self.masterWindow.getVintage()
        if vintage:
            groupName = f"LABELED_DATA_{vintage}"
        else:
            groupName = "LABELED_DATA"

        group = root.findGroup(groupName)
        self.initvLayersList(group)
        #self.mostSegmentedLayer = self.vLayersList[0]
        self.mostSegmentedLayer = self.vLayersList.pop(0)

        finalGroup = root.findGroup(self.workGroupName)

        vlayerFinal = self.createFinalLayer(
            group=finalGroup, vLayer=self.mostSegmentedLayer)

        vintages = self.masterWindow.getVintages()
        self.initDictOfvLayersListByVintageToKeep(vintages)

        for vintage in vintages:
            self.keepOnlyLayersLabeled(vintage=vintage)

        vlayerFinal.startEditing()

        for vintage in self.dictOfvLayersListByVintageToKeep.keys():

            # the table 'attributes Table' contains the attribute names
            # for the most recent vintage
            attributsTable = nomenclatureWidget.getAttributsTable()

            index = 0
            for field in attributsTable:
                if field.split('_')[1] != vintage:
                    attributsTable[index] = f"{field.split('_')[0]}_{vintage}"
                index += 1

            vLayers = self.dictOfvLayersListByVintageToKeep[vintage]

            self.mergingLevels(
                attributsTable=attributsTable,
                vlayerFinal=vlayerFinal,
                vLayers=vLayers
            )

        vlayerFinal.commitChanges(True)

        finalGroup.setExpanded(True)
        finalGroup.setItemVisibilityChecked(False)


    def keepOnlyLayersLabeled(self, vintage:str=None):
        """
            Keep only the layers containing at least one labeled surface.
            the layers to keep added to dictionnary vLayersListByVintageToKeep.

            param listTlayers: layers list.
            returns none.
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        fiedName=f"code_{vintage}"

        for vlayer in self.vLayersList:
            result=self.selectedByAtt(vlayer, fiedName, 'is not null')
            if result['OUTPUT'].selectedFeatureCount()>0:
                self.dictOfvLayersListByVintageToKeep[vintage].append(vlayer)

            vlayer.removeSelection()
            #self.progress.setValue(self.progress.value()+1)


    def setDictFieldIndex(self,
                          attributsTable: list = None,
                          vLayer: QgsVectorLayer = None
                          ):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        self.dictFieldIndex.clear()
        for attr in attributsTable:
            idx = vLayer.dataProvider().fieldNameIndex(attr)
            self.dictFieldIndex[attr] = idx


    def getFielAnddIndex(self, fieldName):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        for key in self.dictFieldIndex.keys():
            if key.startswith(fieldName):
                return key, self.dictFieldIndex[key]
        return None,None


    def setListOfAttValues(self,
                           vLayer: QgsVectorLayer = None):
        """
            param vlayer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        fieldCode, idxCode = self.getFielAnddIndex('code')

        request = QgsFeatureRequest()
        request = request.setFilterExpression(f"{fieldCode} IS NOT NULL")

        selected_features = vLayer.getFeatures(request)

        _, idxClass = self.getFielAnddIndex('class')
        _, idxColor = self.getFielAnddIndex('color')

        for feature in selected_features:
            self.listOfAttValues[feature.attributes()[idxCode]] = [
                feature.attributes()[idxClass],
                feature.attributes()[idxColor]]

        vLayer.removeSelection()


    def getListOfAttValues(self):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        return self.listOfAttValues


    def selectedByAtt(self, vlayer, fieldName, operatorId):
        """
            param vlayer:
            returns none:

            #*************************
            # OPERATOR Values:
            # 0 — =
            # 1 — ≠
            # 2 — >
            # 3 — >=
            # 4 — <
            # 5 — <=
            # 6 — begins with
            # 7 — contains
            # 8 — is null
            # 9 — is not null
            # 10 — does not contain
            #*************************

        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        operator = {'=': 0,
                    '≠': 1,
                    '>': 2,
                    '>=': 3,
                    '<': 4,
                    '<=': 5,
                    'begins with': 6,
                    'contains': 7,
                    'is null': 8,
                    'is not null': 9,
                    'does not contain': 10}

        alg_id = "qgis:selectbyattribute"

        parameter_dictionary = {'INPUT': vlayer,
                                'FIELD': fieldName,
                                'OPERATOR': operator[operatorId],
                                'METHOD': 0  # new selection
                                }
        result = processing.run(alg_id, parameter_dictionary)
        return result


    def createFinalLayer(self, group=None, vLayer=None):
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")
        
        transformContext = QgsProject.instance().transformContext()
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = vLayer.dataProvider().storageType()

        AbsolutePath_FinalData = self.getAbsolutePathFinalData()

        finalFileName = vLayer.name()+"_Final"
        fullPathName_FinalData = AbsolutePath_FinalData+"/"+finalFileName+".shp"

        error = QgsVectorFileWriter.writeAsVectorFormatV3(
            vLayer,
            fullPathName_FinalData,
            transformContext,
            options
        )

        if error[0] != QgsVectorFileWriter.NoError:
            print(f"line:{lineno()}, writeAsVectorFormatV3 fail")

        vlayer_Final = QgsVectorLayer(fullPathName_FinalData,
                                      finalFileName,
                                      "ogr"
                                      )

        self.idVlayer_Final = vlayer_Final.id()

        new_renderer = vLayer.renderer().clone()
        vlayer_Final.setRenderer(new_renderer)

        QgsProject.instance().addMapLayer(vlayer_Final, False)
        # QgsProject.instance().addMapLayer(vlayer_Final)

        tLayer_Final = QgsLayerTreeLayer(vlayer_Final)
        tLayer_Final.setExpanded(False)

        group.insertChildNode(-1, tLayer_Final)

        return vlayer_Final


    def mergingLevels(self,
                      attributsTable:list = None,
                      vlayerFinal:QgsVectorLayer = None,
                      vLayers:list = None
                      ):

        """
            param none:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->"+
        #       f"{inspect.currentframe().f_code.co_name}()")

        prov_vlayerFinal = vlayerFinal.dataProvider()
        caps_vlayerFinal = prov_vlayerFinal.capabilities()

        self.setDictFieldIndex(
            attributsTable=attributsTable,
            vLayer=vlayerFinal
        )

        #Process layers list
        for vLayer in vLayers:

            self.setListOfAttValues(vLayer=vLayer)
            # vLayer.dataProvider().createSpatialIndex()
           
           
            field_Code, idx_Code = self.getFielAnddIndex('code')
            _, idx_Class = self.getFielAnddIndex('class')
            _, idx_Color = self.getFielAnddIndex('color')

            for code_Value in self.listOfAttValues.keys():

                class_Value = self.listOfAttValues[code_Value][0]
                Color_Value = self.listOfAttValues[code_Value][1]
               
                param_sel = {'INPUT': vLayer,
                             'FIELD': field_Code,
                             'OPERATOR': 0,  # 0  =
                             'VALUE': code_Value,
                             'METHOD': 0
                             }
                processing.run('qgis:selectbyattribute', param_sel)
                # self.progress.setValue(self.progress.value()+1)

                param_sel1 = {'INPUT': vlayerFinal,
                              'FIELD': field_Code,
                              'OPERATOR': 8,  # 8= 'is null'
                              'METHOD': 0
                              }
                processing.run('qgis:selectbyattribute', param_sel1)
                #         self.progress.setValue(self.progress.value()+1)

                param_loc = {'INPUT': vlayerFinal,
                             'PREDICATE': 6,  # are within
                             'INTERSECT': QgsProcessingFeatureSourceDefinition(vLayer.id(), True),
                             'METHOD': 2
                             }
                processing.run('qgis:selectbylocation', param_loc)
                # self.progress.setValue(self.progress.value()+1)

                for featureId in vlayerFinal.selectedFeatureIds():
                    if caps_vlayerFinal and QgsVectorDataProvider.ChangeAttributeValues:
                        attrs = {idx_Code: code_Value,
                                 idx_Class: class_Value,
                                 idx_Color: Color_Value
                                 }
                        prov_vlayerFinal.changeAttributeValues(
                            {featureId: attrs})

                vLayer.removeSelection()
                vlayerFinal.removeSelection()
                # self.progress.setValue(self.progress.value()+1)
                