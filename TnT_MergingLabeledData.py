# -*- coding: utf-8 -*-/
"""
/***************************************************************************
TnT_MergingLabeledData
                                 A QGIS plugin
Labelisation de données segmentées.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2021-01-25
        git sha              : $Format:%H$
        copyright            : (C) 2021 by IGN
        authors              : Yann Le Borgne
        email                : yann.le-borgne@ign.fr
        version              : 1.3.0

30/03/2022 Changement dans la classe TnTnomenclatureWidget des methodes d'acces
           aux champs attributaires.

15/03/2022: Ajout de "traces" d' entree dans les méthodes.
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import inspect
import glob
import os
import processing

from PyQt5 import QtCore
from PyQt5.QtWidgets import (QProgressDialog, QMessageBox)
from PyQt5.QtCore import QTimer

from qgis.core import (QgsProject, QgsVectorLayer,
                       QgsProcessingFeatureSourceDefinition,
                       QgsFeatureRequest, QgsVectorDataProvider,
                       QgsLayerTreeLayer, QgsVectorFileWriter)


def lineno():
    """Returns the current line number in Python source code"""
    return inspect.currentframe().f_back.f_lineno

class TnTmergingLabeledData():
    """
    Class responsible for merging the different segmented layers.
    """
    def __init__(self, parent=None):
        self.parent=parent
        self.listTreeLayers2Keep=[]

        # code:[label,labelColor]
        self.listOfAttValues={}

        self.workGroupName='FINAL_DATA'
        self.workGroup=self.getRootGroup().findGroup(self.workGroupName)

        self.progress=None

    def getRootGroup(self):
        """
            returns RootGroup:
        """
        #print(f"line:{lineno()}, TnTlabelingToolsBox->getRootGroup()")
        return self.parent.getRootGroup()

    def getWorkGroup(self):
        """
        Return the current workgroup.
            returns self.workGroup: the value of the attribute self.workGroup.
        """
        #print(f"line:{lineno()}, TnTlabelingToolsBox->getWorkGroup()")
        return self.workGroup

    def mergeAll(self, listTlayers):
        """
        Merge all the segmented layers present in the sorted list "listTlayers".
            param listTlayers: The sorted list of segmented layers.
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")

        # Contourment du bug de la 3.14
        # Test de l'existence de données dans le groupe final.
        # Si oui, executer pour l'utilisateur un stop/start qui permet de liberer
        # l'acces au shapefile finaux si ils existent, de les supprimer et de regenerer
        # un jeu de données final.

        self.parent.getPushButton("Fill_Pyramid").setEnabled(False)
        returnMsgValue = 0

        if  QgsProject.instance().layerTreeRoot().findGroup(self.workGroupName).findLayers():
            returnMsgValue=self.showMsgBox()
        if returnMsgValue == QMessageBox.Ok :
            self.reMerge(self.parent)
        elif returnMsgValue == QMessageBox.Cancel :
            #self.doNothing()
            pass
        else:
            self.merge(listTlayers)

        self.parent.getPushButton("Fill_Pyramid").setEnabled(True)

    def merge(self, listTlayers ):
        """
            param listTlayers:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.progress=self.showProgressDialog(self.parent)
        self.progress.setModal(True)
        self.progress.setMinimum(0)
        self.progress.setMaximum(len(listTlayers)*18)

        self.keepOnlyLayersLabeled(listTlayers)

        if self.listTreeLayers2Keep :
            self.mergingLevels()
            self.progress.setLabelText("Processing Done.")
        else :
            self.progress.setLabelText("Nothing to do!!!.")

        self.progress.setValue(self.progress.maximum())
        timer = QTimer()
        timer.timeout.connect(lambda:(self.stop(timer)))
        timer.start(2000)

    def reMerge(self, parent):
        """
            param parent:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        parent.enterStopMode()
        parent.enterStartMode()

        timer = QTimer()
        timer.timeout.connect(lambda:(self.simpleStop(timer)))
        timer.start(2000)

         # Suppression bestiale des fichiers presents dans le rep FINAL_DATA/<nomenclature_name>
        projectAbsolutePath=QgsProject.instance().absolutePath()
        #currentNomenclatureName=self.parent.mainWindow.nomenclatureWidget.nomenclatureSelector.currentText()
        currentNomenclatureName=self.getNomenclature().currentText_NomenclatureQComboBox()
        AbsolutePath_FinalData=projectAbsolutePath+"/"+self.workGroupName+"/"+currentNomenclatureName.upper()+"/*"

        files = glob.glob(AbsolutePath_FinalData)
        for f in files:
            os.remove(f)

        #Cette liste a ete effacée lors du stop/start, on la recharge
        listTlayers=parent.listLabeledLayers4Merging
        self.merge(listTlayers)

    def doNothing(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        self.progress=self.showProgressDialog(self.parent)
        self.progress.setLabelText("Nothing to do!!!.")
        self.progress.setValue(self.progress.maximum())
        timer = QTimer()
        timer.timeout.connect(lambda:(self.stop(timer)))
        timer.start(2000)

    def getNomenclature(self):
        """
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}")
        return self.parent.mainWindow.nomenclatureWidget

    def simpleStop(self, timer):
        """
            param timer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        timer.stop()

    def stop(self, timer):
        """
            param timer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        timer.stop()
        self.progress.close()

    # Deleted files data failed, BUG on QGIS 3.14
    # def deletePreviousMerge (self):
    #     #print(f"line:{lineno()}, ->TnTmergingLabeledData:deletePreviousMerge()")
    #     projectAbsolutePath=QgsProject.instance().absolutePath()
    #     currentNomenclatureName=self.parent.mainWindow.nomenclatureWidget.nomenclatureSelector.currentText()
    #     AbsolutePath_FinalData=projectAbsolutePath+"/"+self.workGroupName+"/"+currentNomenclatureName.upper()

    #     group=QgsProject.instance().layerTreeRoot().findGroup(self.workGroupName)

    #     root=QgsProject.instance().layerTreeRoot()

    #     self.listTreeLayers.clear()
    #     self.listOfAttValues.clear()

    #     for tLayer in group.findLayers():
    #         vLayer = QgsProject.instance().mapLayersByName(tLayer.layer().name())[0]
    #         vLayer_treeLayer = root.findLayer(vLayer.id())
    #         parent_group = vLayer_treeLayer.parent()
    #         vLayer_treeLayer.setExpanded(False)
    #         vLayer_treeLayer.setItemVisibilityChecked(False)
    #         parent_group.removeChildNode(vLayer_treeLayer)

    #     try:
    #         os.chdir(AbsolutePath_FinalData)
    #     except FileNotFoundError:
    #          pass
    #     else :
    #         for shpfile in glob.glob("*.shp"):
    #            if not  QgsVectorFileWriter.deleteShapeFile(shpfile):
    #                print(f"file : {shpfile} not deleted")

    def keepOnlyLayersLabeled(self, listTlayers):
        """
            Keep only the layers containing at least one labeled surface.
            the layers to keep added to list "self.listTreeLayers2Keep".

            param listTlayers: layers list.
            returns none.
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}(listTlayers:{listTlayers})")

        fiedName = (self.getNomenclature().getTableAttributsName())[1]

        self.listTreeLayers2Keep.clear()
        self.progress.setValue(0)
        for tlayer in listTlayers:
            result=self.selectedByAtt(tlayer.layer(), fiedName, 'is not null')
            if result['OUTPUT'].selectedFeatureCount()>0:
                self.listTreeLayers2Keep.append(tlayer)
            tlayer.layer().removeSelection()
            self.progress.setValue(self.progress.value()+1)

    def duplicateData4Merge(self, vlayer):
        """
            param vlayer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        transformContext = QgsProject.instance().transformContext()
        options = QgsVectorFileWriter.SaveVectorOptions()
        options.driverName = vlayer.dataProvider().storageType()

        projectAbsolutePath=QgsProject.instance().absolutePath()
        currentNomenclatureName=self.getNomenclature().currentText_NomenclatureQComboBox()

        finalFileName=vlayer.name()+"_Final"
        AbsolutePath_FinalData=projectAbsolutePath+"/"+self.workGroupName+"/"+currentNomenclatureName.upper()
        os.makedirs(AbsolutePath_FinalData, exist_ok=True)
        FullPathName_FinalData=AbsolutePath_FinalData+"/"+finalFileName+".shp"

        error=QgsVectorFileWriter.writeAsVectorFormatV2(vlayer,
                                                  FullPathName_FinalData,
                                                  transformContext,
                                                  options)

        if error[0] != QgsVectorFileWriter.NoError:
            print(f"line:{lineno()}, TnTmergingLabeledData:QgsVectorFileWriter.writeAsVectorFormatV2 fail")

        vlayer_FinalData = QgsVectorLayer(FullPathName_FinalData,
                                              finalFileName,
                                              "ogr")

        new_renderer=vlayer.renderer().clone()
        vlayer_FinalData.setRenderer(new_renderer)

        QgsProject.instance().addMapLayer(vlayer_FinalData,False)
        tVlayer_FinalData=QgsLayerTreeLayer(vlayer_FinalData)
        tVlayer_FinalData.setExpanded(False)

        wGroup=self.getWorkGroup()
        wGroup.insertChildNode(-1, tVlayer_FinalData)

        return vlayer_FinalData

    def showProgressDialog(self, parent):
        """
            param parent:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        progress = QProgressDialog(parent)
        progress.setWindowTitle("Fill Pyramid Process")
        progress.setLabelText("Processing in progress....")
        progress.setCancelButtonText(None)
        progress.setMinimumDuration(5)
        progress.setWindowModality(QtCore.Qt.WindowModal)
        progress.setAutoClose(False)
        progress.setAutoReset(False)
        return progress

    def showMsgBox(self):
        """
            param none:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        messageBox = QMessageBox()
        messageBox.setIcon(QMessageBox.Warning)
        messageBox.setWindowTitle("TrainMinaTor message")
        messageBox.setText("Final data already exists, do you want to overwrite it?")
        messageBox.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
        returnMessageBox = messageBox.exec()
        return returnMessageBox

    def mergingLevels(self):
        """
            param none:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()"
        tLayerBase=self.listTreeLayers2Keep.pop(0)
        layerBase=tLayerBase.layer()

        vlayer_FinalData=self.duplicateData4Merge(layerBase)

        prov_vlayer_FinalData=vlayer_FinalData.dataProvider()
        caps_vlayer_FinalData=prov_vlayer_FinalData.capabilities()
        prov_vlayer_FinalData.createSpatialIndex()

        fieldCode=(self.getNomenclature().getTableAttributsName())[0]
        fieldLabel=(self.getNomenclature().getTableAttributsName())[1]
        fieldColor=(self.getNomenclature().getTableAttributsName())[2]

        idx_code       = prov_vlayer_FinalData.fieldNameIndex(fieldCode)
        idx_label      = prov_vlayer_FinalData.fieldNameIndex(fieldLabel)
        idx_labelColor = prov_vlayer_FinalData.fieldNameIndex(fieldColor)

        vlayer_FinalData.startEditing()

        #Process the rest of the items in the list
        for tLayer2Merge in self.listTreeLayers2Keep :

            layer2Merge=tLayer2Merge.layer()
            layer2Merge.dataProvider().createSpatialIndex()
            self.getListOfAttValues(layer2Merge)

            for codeValue in self.listOfAttValues:
                param_sel = { 'INPUT':layer2Merge,
                              'FIELD':fieldCode,
                              'OPERATOR':0,  #0  =
                              'VALUE':codeValue,
                              'METHOD':0
                             }
                processing.run('qgis:selectbyattribute',param_sel)
                self.progress.setValue(self.progress.value()+1)

                param_sel1 = {'INPUT':vlayer_FinalData,
                              'FIELD':fieldCode,
                              'OPERATOR':8,    #8= 'is null'
                              'METHOD':0
                             }
                processing.run('qgis:selectbyattribute',param_sel1)
                self.progress.setValue(self.progress.value()+1)

                param_loc = { 'INPUT':vlayer_FinalData,
                              'PREDICATE': 6, #are within
                              'INTERSECT':QgsProcessingFeatureSourceDefinition(layer2Merge.id(), True),
                              'METHOD':2
                             }
                processing.run('qgis:selectbylocation',param_loc)
                self.progress.setValue(self.progress.value()+1)

                labelValue=self.listOfAttValues[codeValue][0]
                labelColorValue=self.listOfAttValues[codeValue][1]

                for featureId in vlayer_FinalData.selectedFeatureIds():
                    if caps_vlayer_FinalData and QgsVectorDataProvider.ChangeAttributeValues:
                        attrs = {idx_code:codeValue, idx_label:labelValue, idx_labelColor:labelColorValue}
                        prov_vlayer_FinalData.changeAttributeValues({ featureId : attrs })

                layer2Merge.removeSelection()
                vlayer_FinalData.removeSelection()
                self.progress.setValue(self.progress.value()+1)

            self.progress.setValue(self.progress.value()+1)

        vlayer_FinalData.commitChanges(True)

    def getListOfAttValues(self, vlayer):
        """
            param vlayer:
            returns none:
        """
        print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")

        fieldCode=(self.getNomenclature().getTableAttributsName())[0]
        fieldLabel=(self.getNomenclature().getTableAttributsName())[1]
        fieldColor=(self.getNomenclature().getTableAttributsName())[2]

        request = QgsFeatureRequest()

        reqtext='"{}" IS NOT NULL'.format(fieldLabel)
        request = request.setFilterExpression('{}'.format(reqtext))

        selected_features = vlayer.getFeatures(request)

        idx_code = vlayer.dataProvider().fieldNameIndex(fieldCode)
        idx_label = vlayer.dataProvider().fieldNameIndex(fieldLabel)
        idx_labelColor = vlayer.dataProvider().fieldNameIndex(fieldColor)

        for feature in selected_features:
            self.listOfAttValues[ feature.attributes()[idx_code] ] = [
                feature.attributes()[idx_label],
                feature.attributes()[idx_labelColor] ]

        vlayer.removeSelection()

    def selectedByAtt(self, vlayer, fieldName, operatorId):
        """
            param vlayer:
            returns none:
        """
        # print(f"line:{lineno()},{self.__class__.__name__}->{inspect.currentframe().f_code.co_name}()")
        #INPUT
        #FIELD
        #OPERATOR
        #VALUE
        #METHOD
        #*************************
        # OPERATOR Values:
        # 0 — =
        # 1 — ≠
        # 2 — >
        # 3 — >=
        # 4 — <
        # 5 — <=
        # 6 — begins with
        # 7 — contains
        # 8 — is null
        # 9 — is not null
        # 10 — does not contain
        #*************************

        operator={'=':0,
                  '≠':1,
                  '>':2,
                  '>=':3,
                  '<':4,
                  '<=':5,
                  'begins with':6,
                  'contains':7,
                  'is null':8,
                  'is not null':9,
                  'does not contain':10 }

        alg_id="qgis:selectbyattribute"

        parameter_dictionary = {'INPUT':vlayer,
                                'FIELD':fieldName,
                                'OPERATOR': operator[operatorId],
                                'METHOD':0     #new selection
                                }
        result=processing.run(alg_id, parameter_dictionary)
        return result
